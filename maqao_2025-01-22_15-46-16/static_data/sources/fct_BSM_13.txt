/tools/acfl/24.04/gcc-13.2.0_AmazonLinux-2/include/c++/13.2.0/bits/allocator.h: 184 - 184
--------------------------------------------------------------------------------

184:       ~allocator() _GLIBCXX_NOTHROW { }
/fsx/home/etud9-1/Black-sholes/BSM.cxx: 95 - 105
--------------------------------------------------------------------------------

95:     #pragma omp parallel for reduction(+:sum)
[...]
101:             thread_local static std::mt19937 generator(std::random_device{}());
102:             thread_local static std::normal_distribution<double> distribution(0.0, 1.0);
103:             alignas(32) double Z =  distribution(generator);
104:             if (Z > lnZcompare) {
105:                 sum+= a*exp(lambda* Z)+b; 
/tools/acfl/24.04/gcc-13.2.0_AmazonLinux-2/include/c++/13.2.0/bits/random.h: 143 - 2073
--------------------------------------------------------------------------------

143: 	    __res %= __m;
[...]
194: 	                            _Engine>(_M_g);
[...]
1658:     random_device() { _M_init("default"); }
[...]
1664:     { _M_fini(); }
[...]
1680:     { return this->_M_getval(); }
[...]
2034: 	: _M_mean(__mean), _M_stddev(__stddev)
[...]
2073:       : _M_param(__mean, __stddev)
/tools/acfl/24.04/gcc-13.2.0_AmazonLinux-2/include/c++/13.2.0/bits/basic_string.h: 189 - 792
--------------------------------------------------------------------------------

189: 	: allocator_type(__a), _M_p(__dat) { }
[...]
223:       { return _M_dataplus._M_p; }
[...]
264: 	if (_M_data() == _M_local_data())
[...]
289:       { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }
[...]
639: 	_M_construct(__s, __end, forward_iterator_tag());
[...]
792:       { _M_dispose(); }
/tools/acfl/24.04/gcc-13.2.0_AmazonLinux-2/include/c++/13.2.0/bits/new_allocator.h: 168 - 168
--------------------------------------------------------------------------------

168: 	_GLIBCXX_OPERATOR_DELETE(_GLIBCXX_SIZED_DEALLOC(__p, __n));
/tools/acfl/24.04/gcc-13.2.0_AmazonLinux-2/include/c++/13.2.0/bits/random.tcc: 330 - 1839
--------------------------------------------------------------------------------

330:       _M_x[0] = __detail::__mod<_UIntType,
331: 	__detail::_Shift<_UIntType, __w>::__value>(__sd);
332: 
333:       for (size_t __i = 1; __i < state_size; ++__i)
334: 	{
335: 	  _UIntType __x = _M_x[__i - 1];
336: 	  __x ^= __x >> (__w - 2);
337: 	  __x *= __f;
338: 	  __x += __detail::__mod<_UIntType, __n>(__i);
339: 	  _M_x[__i] = __detail::__mod<_UIntType,
340: 	    __detail::_Shift<_UIntType, __w>::__value>(__x);
341: 	}
342:       _M_p = state_size;
[...]
1817: 	if (_M_saved_available)
1818: 	  {
1819: 	    _M_saved_available = false;
1820: 	    __ret = _M_saved;
[...]
1827: 		__x = result_type(2.0) * __aurng() - 1.0;
1828: 		__y = result_type(2.0) * __aurng() - 1.0;
1829: 		__r2 = __x * __x + __y * __y;
1830: 	      }
1831: 	    while (__r2 > 1.0 || __r2 == 0.0);
1832: 
1833: 	    const result_type __mult = std::sqrt(-2 * std::log(__r2) / __r2);
1834: 	    _M_saved = __x * __mult;
1835: 	    _M_saved_available = true;
1836: 	    __ret = __y * __mult;
1837: 	  }
1838: 
1839: 	__ret = __ret * __param.stddev() + __param.mean();
